fork只拷贝下一个要执行的代码到新的进程。
fork仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
1）在父进程中，fork返回新创建子进程的进程ID；
2）在子进程中，fork返回0；
3）如果出现错误，fork返回一个负值；


fork出错可能有两种原因：
1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
2）系统内存不足，这时errno的值被设置为ENOMEM

----
创建新进程成功后，系统中出现两个基本完全相同的进程，
这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。

----
eg eg2 差一个 \n 结果不同
这跟printf的缓冲机制有关，printf某个内容时，操作系统仅仅是吧该内容放到了stdout的缓冲队列里面，并没有把内容实际写到屏幕上，
但只要看到\n就会立即刷新stdout，因此马上就能够打印出内容

printf("fork!") 没有\n时，stdout的内容也被子进程复制过去了

----

fork()子进程和父进程共享的资源:
====
打开的文件
实际用户ID、实际组ID、有效用户ID、有效组ID
添加组ID
进程组ID
对话期ID
控制终端。 
设置-用户-ID标志和设置-组-ID标志
当前工作目录
根目录
文件方式创建屏蔽字
信号屏蔽和排列
对任一打开文件描述符的在执行时关闭标志
环境
连接的共享存储段（共享内存）
资源限制

父、子进程之间的区别是： 
====
fork的返回值
进程ID
不同的父进程ID
子进程的tms_utime,tms_stime,tms_cutime以及tms_ustime设置为0
父进程设置的锁，子进程不继承
子进程的未决告警被清除
子进程的未决信号集设置为空集

